2020年5月21日 12:32:42

### 目录

1. 线程与进程区别
2. 线程生命周期
3. 线程原理
4. 线程声明方式

### 1. 线程与进程区别

#### 1.1 进程的定义 

进程是60年代初首先由麻省理工学院的MULTICS系统和IBM公司的CTSS/360系统引入的。

进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。

进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，程序是指令、数据及其组织形式的描述，进程是程序的实体，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。进程是程序在内存中的状态。

在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。

进程是正在运行的程序的实例，是操作系统动态执行的基本单元，是操作系统分配资源的基本单位。

#### 1.2 进程的存在形式

进程是一个实体，有自己的地址空间，包括进程控制块（PCB）、程序段、数据段。

一旦操作系统调用进程创建原语create()按下述步骤创建一个新进程：

1. 新进程获取唯一数字识别符，并从PCB集合中申请一个空白PCB用
2. 新进程程序、数据、用户栈分配必要内存空间
3. 初始化进程控制块PCB，分为三小步：

1. 1. 初始化标识信息，将系统分配的标识符和父进程标识符载入PCB
   2. 初始化处理器状态信息，将PC指向程序入口，栈指针指向栈顶
   3. 初始化处理器控制信息，将进程设为就绪状态，设置优先级

4. 新进程插入到就绪队列中

关于操作系统的状态：

1. 内核态（管态）supervisor model ：就是操作系统进程（程序）执行时候的状态，允许使用全部系统资源和指令。

2. 用户态（目态）user model ：就是用户程序执行时的状态，不能执行特定指令，不能直接访问系统资源，只能访问自己的存储区域。

#### 1.3 进程的切换 

进程从就绪状态变为运行状态时过程为，进程得到了处理器的使用权，进程中私有栈中的寄存器数据 复制到 处理器的寄存器中，并把进程断点送入操作系统PC中，该进程就开始执行。

当没有使用权，由运行状态转为阻塞状态时，会把处理器的寄存器中数据 再复制到 自己私有的寄存器中， 等待下次执行。

在切换时，有个上下文的概念本质是数据。一个进程在处理器的寄存器中间的数据叫做这个进程的上下文，进程切换就是两个进程之间上下文的切换，一个到处理器寄存器，一个到自己私有栈中。
当进程无法继续执行时，会自己主动调用进程阻塞原语block()把自己阻塞。PCB控制信息更改为阻塞，并把PCB进入阻塞队列中。

当进程可以执行时，由其他进程调用唤醒原语wakeup将该进程唤醒。先移除阻塞队列，然后改变PCB控制信息为就绪，再放入就绪状态。

调度算法：先进先出、最短作业优先、最短剩余时间优先 | 时间片轮转，最高优先级，最短进程优先。

#### 1.4 线程的概念 

操作系统为了支持并发活动，提出了进程；为了提高并发能力，提出了线程。线程就是进程执行的一个路径（单一顺序的控制流），有自己的栈和执行环境（处理器寄存器），可以完全占有父进程的所有资源。

线程是操作系统执行调用和分派的最小单位，当支持线程时，就只调用线程而不调用进程，是进程的实际运作单位。一个线程包括PC、私有调用栈（call stack）、私有寄存器环境（register context）、线程本地存储（thread-local storage）。

线程实体包括TCB、程序段、数据段。

### 2. 线程生命周期

线程可以分为：创建、就绪、运行、等待（挂起）、结束五个生命周期

#### 2.1 **进程与线程的区别**

可以从以下四个方面：

1.  地址空间和资源：进程间相互独立，同一个进程的各个线程共享
2. 通信：进程间通过IPC，线程可直接读写进程数据段（需进程同步互斥辅助，以保证数据的一致性）
3. 调度与切换：线程上下文切换比进程上下文快
4. 执行单位：多线程OS中，执行单位只有线程，没有进程

#### 2.2 进程的同步

进程有两种状态：同步和互斥。由于进程间是互相独立的，互斥是基本的状态，从对系统资源的访问到对某个文件的读写。同步是指进程间并发需要相互等待与相互沟通，是一种协作关系，需要一种同步规则完成这些功能。

同步规则目的是使多个进程之间可以正常等待正常通信，正常协作，有两种方式：信号量PV操作和加锁操作。

进程在访问共享资源之前需要进行一下操作：

1. 检查锁状态，是0还是1
2. 如果为0，则置1，表示上锁占有该资源
3. 如果为1，表示资源已被占用，返回第一步重新观察

上锁原语为lock，开锁原语为unlock。

#### 2.3 进程间的通信 

上面讲进程同步时，介绍了两种方式，这两种方式均是通过共享的存储器来实现的，只能几个字的读取写入信息，效率低。为了进程间高效通信，提供了一种进程通信interprocess communication IPC机制。通过一个消息信息块，IPC利用这个消息，明确的把消息从一个进程的地址空间拷贝到另一个进程的地址空间中，而不是使用共享数据区，让进程自己去取。

消息通信中有两个原语：send，receive。

### 3. 线程原理

#### 3.1 Java锁概述

Java为了实现线程同步，提供了两种锁，一种是系统级别的synchronized加锁方式，一种是颗粒度更细的lock加锁方式。

Java每一个对象都可以作为锁，对于synchronized加锁，分为三种情况：

1. 对普通方法加锁，加锁的是该对象，叫对象锁
2. 对静态方法加锁，加锁的是该当前类的Class对象
3. 对同步代码块，加锁的是synchronized括号里的对象

前提条件：当一个对象访问同步代码时，必须要先得到锁，退出或异常要释放锁。

操作系统先通过总线锁和缓存锁保证自己的操作是原子性的。

Java通过锁（偏向锁、轻量级锁、互斥锁）和循环CAS来保证原子性。

并发编程两个问题：线程之间如何同步，线程之间如何通信（共享内存或消息传递）。

#### 3.2 Java锁内存原理

Java内存模型JMM如下图，两个线程会有自己的本地内存并存储了共享变量的副本，父进程内存中存了共享变量，对共享变量的修改需要经过JMM读写操作才能实现。

![img](C:\code\github\java-interview\img\nio-5.png)

对于加锁和释放锁的原理，就是对JMM操作的原理

线程A释放锁，实质上是线程A向接下来将要获取这个变量锁的线程发出消息（A修改了这个共享变量，并把值从A内存中更新到了主内存中）

线程B获得锁，实质上是线程B接受到了某个线程发出的消息（JMM使线程B本地内存中的变量无效，迫使B去读取主内存变量值）

所以线程A释放锁，线程B得到锁，本质上是线程A通过主内存向线程B发送消息。

![img](C:\code\github\java-interview\img\thread-1.png)

#### 3.3 **Java锁原理**

任何对象都有一个监视器，当对象中的方法被synchronized修饰时，线程要想执行该同步方法或同步块，必须先获得该对象的监视器，如果没有获取到，则该线程进入同步对列SynchronizedQueue中，并变为阻塞状态。当前一个线程释放该对象锁时，会唤醒一个队列中的线程并重新获取对象监视器。

当线程获得监视器后，其他线程自动进入同步队列中并阻塞。

![img](C:\code\github\java-interview\img\thread-2.png)

等待 wait 和通知 notify|notifyAll 是Java每个对象都具备的，定义在 Object 类上。所以线程调用的上面方法，其实是对象身上的，不是线程自带的。像对象开关，wait 相当于把对象关了，notify 把对象开了。故线程调用 wait方法，会释放对象锁进入等待状态；线程A调用 notify 方法，会唤醒线程B继续执行。类似进程中的 lock|unlock或p|v操作。

所以，调用 wait|notify 方法需要先获得对象锁，对对象加锁。调用 wait 方法，线程由运行转为等待，释放锁并进入 object watingqueu e中就是常说的对象等待队列中。调用 notify 方法，并不会立刻唤醒 wait 等待线程，因为第一条是加了对象锁，故调用 notify 并释放了对象锁，wait 线程才有机会从 wait 返回。

notify 会把等待队列中的一个线程从等待队列放入同步队列。notifyAll 会把等待队列中的所有线程放入同步队列，这些线程由等待变为阻塞。

![img](C:\code\github\java-interview\img\thread-3.png)

关于Thread.join()方法

```java
public final synchronized void join(){
    while(isAlive()){
        wait(0);
    }
}
```

从源码可以看到join就是实现了wait和notify统一。

SynchronizedQueue是一个不存储元素的同步队列（阻塞队列），下一个元素的put操作，必须等待上一个元素take操作完成。

#### 3.4 Fork|Join 实现原理 

Fork把大任务分成小任务，Join把小任务结果合并为大任务最终结果。

原理是工作窃取算法和双端队列。Java提供了继承ForkJoinTask类的两个子类：

1.  RecursiveAction ： 用于没有返回结果的任务
2.  RecursiveTask ：用于有返回结果的任务

然后通过ForkJoinPool类构建的双端队列执行任务。

### 4. 线程声明方法

#### 4.1 无返回值 Runnable

Thread 调用 Runnable

#### 4.2 有返回值 Callable

FutrueTask 调用 Callable