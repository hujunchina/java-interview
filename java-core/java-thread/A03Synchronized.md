2020年5月21日 14:12:06

### 目录

1. Synchronized 是什么
2. Synchronized 原理
3. Synchronized 实例

### 1. Synchronized 是什么

J.U.C 包中的工具类是基于 synchronized、volatile、CAS、ThreadLocal 这样的并发核心机制打造的。

所以，要想深入理解 J.U.C 工具类的特性、为什么具有这样那样的特性，就必须先理解这些核心机制。

synchronized关键字是通过加锁来实现线程的互斥同步，保证同一时刻只能有一个线程访问共享区域（临界区），竞态条件（Race Condition）：当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。临界区（Critical Sections）：导致竞态条件发生的代码区称作临界区。

#### 1.1 对象锁（monitor）机制

![SynchronizedDemo.class](C:\code\github\java-interview\img\thread-10.png)

如图，上面用黄色高亮的部分就是需要注意的部分了，这也是添Synchronized关键字之后独有的。执行同步代码块后首先要先执行**monitorenter**指令，退出的时候**monitorexit**指令。通

过分析之后可以看出，使用Synchronized进行同步，其关键就是必须要对对象的监视器monitor进行获取，当线程获取monitor后才能继续往下执行，否则就只能等待。而这个获取的过程是**互斥**的，即同一时刻只有一个线程能够获取到monitor。

上面的demo中在执行完同步代码块之后紧接着再会去执行一个静态同步方法，而这个方法锁的对象依然就这个类对象，那么这个正在执行的线程还需要获取该锁吗？答案是不必的，从上图中就可以看出来，执行静态同步方法的时候就只有一条monitorexit指令，并没有monitorenter获取锁的指令。这就是**锁的重入性**，即在同一锁程中，线程不需要再次获取同一把锁。Synchronized先天具有重入性。**每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一**。

#### 1.2 synchronized的happens-before关系

![synchronized的happens-before关系](C:\code\github\java-interview\img\thread-11.png)

在图中每一个箭头连接的两个节点就代表之间的happens-before关系，黑色的是通过程序顺序规则推导出来，红色的为监视器锁规则推导而出：**线程A释放锁happens-before线程B加锁**，蓝色的则是通过程序顺序规则和监视器锁规则推测出来happens-befor关系，通过传递性规则进一步推导的happens-before关系。现在我们来重点关注2 happens-before 5，通过这个关系我们可以得出什么？

根据happens-before的定义中的一条:如果A happens-before B，则A的执行结果对B可见，并且A的执行顺序先于B。线程A先对共享变量A进行加一，由2 happens-before 5关系可知线程A的执行结果对线程B可见即线程B所读取到的a的值为1。

### 2. Synchronized 原理

原理是：javac编译代码后，其加锁的语句前后有monitor-enter和monitor-exit两个语句，这两个字节码指令，这两个字节码指令都需要一个引用类型的参数来指明要锁定和解锁的对象。每个类都有一个monitor对象，一个monitor包含一个锁、一个同步队列、一个等待队列。

所以当线程执行竞态代码时，先执行monitor-enter，monitor（操作系统内核态）检测有没有锁，如果有就给该线程；如果没有就把线程放在同步队列中。

其他线程执行monitor-exit时，monitor解锁，会从同步队列中选一个线程加锁，不是按先来顺序给锁，所以是非公平的。

#### 2.2 加锁方式

加锁方式3中，对象锁，class对象锁，自己指定对象加锁

特性：原子性，可见性，有序性满足：

可重入性，同步的代码块可以在得到外锁的情况下，自动得到里面的锁，避免死锁发送（互相争夺资源）

非公平性，同步的临界区在选择线程时，是非公平的

互斥性（操作的原子性），同步代码块会阻塞其他线程访问

可见性，在线程退出临界区（monitor-exit）时保证工作内存的数据写入到主内存中

#### 2.3 锁优化

锁优化：轻量级锁、偏向锁、适应性自旋、锁粗化、锁消除。

Synchronized锁状态: 无锁状态->偏向锁->轻量级锁->重量级锁

Java 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定

锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除

锁粗化如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。

偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。

轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。

#### 2.4 锁状态

Synchronized锁状态改变，一开始是偏向锁状态：把锁给第一个加锁的线程，不进行cas同步操作
偏向锁依据：对于绝大部分锁，在整个同步周期内不仅不存在竞争，而且总由同一线程多次获得
如果多个线程访问同步区，那么锁升级为轻量级锁，基于cas机制比较并设置，不断尝试修改直到成功或失败
如果cas次数过多会转为重量级锁
重量级锁就是上面介绍的内容，使用moniter object机制，底层是mutex互斥量实现的，所以增加了系统的开销。
而轻量级锁使用cas，基于乐观并发策略，不使用互斥量，减少开销
偏向锁连cas尝试都不用，直接是给第一个加锁的线程。

重量级     互斥量       monitor object
轻量级     不断尝试     cas
偏向锁     直接给       第一个线程

#### 2.5 Java对象头

在同步的时候是获取对象的monitor,即获取到对象的锁。那么对象的锁怎么理解？无非就是类似对对象的一个标志，那么这个标志就是存放在Java对象的对象头。Java对象头里的Mark Word里默认的存放的对象的Hashcode,分代年龄和锁标记位。32为JVM Mark Word默认存储结构为：

![Mark Word存储结构](C:\code\github\java-interview\img\thread-12.png)

如图在Mark Word会默认存放hasdcode，年龄值以及锁标志位等信息。

Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：**无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态**，这几个状态会随着竞争情况逐渐升级。**锁可以升级但不能降级**，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。对象的MarkWord变化为下图：

![Mark Word状态变化](C:\code\github\java-interview\img\thread-13.png)


### 3. Synchronized 实例