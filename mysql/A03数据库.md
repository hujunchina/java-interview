2020年5月24日 10:54:49

[TOC]

# 1. 存储引擎

MySQL存储引擎可分为 InnoDB 和 MyISAM 两种，还有其他第三方引擎等多种。

数据库是分层设计的，最上层服务应用和数据库共有的，包括连接处理、授权认证、安全等。第二层是服务模块，包括查询缓存、解析器、优化器等；重要的数据库特性都在这一层，包括存储过程、触发器、视图等。

第三层是存储引擎，负责数据的存储和读取，并向上暴露服务API。

MySQL 会为每个数据库创建一个目录，并在目录中创建和表同名的 `.frm` 文件用于保存表的定义。

我们可以通过 `show table status` 查看表的定义，和这个表使用了什么存储引擎。

## 1.1 MyISAM

MySQL 旧版本默认的存储引擎，提供了全文索引、压缩表、空间函数等。不支持事务和行级锁，且无法在崩溃后安全恢复。

### 1.1.1 存储

存储两个文件：`.myd` 表示数据文件和 `.myi` 表示索引文件。

### 1.1.2 特性

#### 1.1.2.1 加锁与并发

MyISAM 会对整张表加锁，即所谓的表锁，颗粒度很大，会严重降低并发量。读取时对表加共享锁，写入时对表加排他锁。故当表读取时，可以向表中插入新的记录。

可以用于非用户表的存储，比如数据库的信息表，可以用MyISAM存储引擎。

#### 1.1.2.2 修复

`check table mytable` 检查表的错误；

`repair table mytable` 修复错误。

#### 1.1.2.3 索引特性

可以支持全文索引（基于分词创建实现的索引），但不支持聚簇索引等。底层使用的是B树。

### 1.1.3 压缩表

如果插入的数据，不会在进行修改操作，适合MyISAM的压缩表特性。可以极大的减少磁盘占用，可以提升查询性能，可以支持只读索引。

### 1.1.4 性能

对存储很友好，把数据以紧凑的格式存储并压缩，适用于存档数据存储，比如历年的账单，不会再被修改可以用MyISAM存储以减少存储空间。

但不适用与高并发和频繁修改的表，因为会对整张表加锁，很多查询都会处于 Locked 状态。

## 1.2 InnoDB

### 1.2.1 概览

InnoDB 出现的晚且是很多开发人员成果。提供排序创建索引、删除增加索引时不用复杂全表数据、大型存储类型BLOB格式等。

### 1.2.2 高并发

采用 MVCC 来支持高并发，实现了四个标准的事务隔离等级，但默认等级是 `REPEATABLE READ` 可重复读等级。并通过间隙锁来避免幻读的问题。间隙锁不仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。 

### 1.2.3 索引

InnoDB 的表都是基于聚簇索引建立的，其对主键查询性能很高。其二级索引必须包含主键列，以便回表操作。

如果索引很多的话，主键要尽可能的小。

### 1.2.4 优化

内部优化有：

- 从磁盘读取数据时采用可预测性预读
- 能够自动在内存中创建hash索引以加速读操作的自适应哈希索引
- 加速插入操作的插入缓冲区

### 1.2.4 支持事务

InnoDB 默认是支持事务的，如果语句没有指明用事务，那么也会当做事务去执行。同时，InnoDB通过一些机制支持真正的热备份。

## 1.3 区别

### 1.3.1 索引不同

MyISAM 索引叶子节点存储的是数据记录地址指针，而InnoDB叶子节点存储的是主键的值。

### 1.3.2 事务支持

MyISAM不支持事务，而InnoDB支持事务，并实现了隔离等级。

### 1.3.3 锁

MyISAM 提供的是表锁，适合高性能；InnoDB提供的是行锁，适合高并发。

# 2. 索引

MySQL的存储引擎都是支持索引的，只是对索引的建立和使用有区别，但第二层的解析器对语法的规定是相同的，这样可以实现对底层的隔离。

```mysql
CREATE INDEX index_name
	ON table_name(column_name);
```

索引底层使用 B+ 树实现，需要占用空间存储数据，根据树特定对键值进行排序。

那么在查询的时候可以以 logN 速度找到结果。

## 2.1 一个测试

### 2.1.1 建表和插入数据

```mysql
create table books(
  id int not null primary key auto_increment,
  name varchar(255) not null,
  author varchar(255) not null,
  created_at datetime not null default current_timestamp,
  updated_at datetime not null default current_timestamp on update current_timestamp
)engine=InnoDB;
```

MySQL 关键字 `primary key` 自增形式 `auto_increment`，时间类型用 `datetime` ，还有一个提供当前时间的函数 `current_timestamp`。

```mysql
drop procedure prepare_data;
delimiter //
create procedure prepare_data()
begin
  declare i int;
  set i = 0;
  while i < 1000000
    do
      insert into books(name, author) value (concat('name', i), concat('author', i));
      set i = i + 1;
    end while;
end //
delimiter ;
call prepare_data();
```

插入数据使用了 SQL 语法（存储过程）定义了一个 prepare_data 的函数。

由于 MySQL 默认是 ；结尾，首先要通过关键字 `delimiter` 指定新的结尾 `//` 。然后就是声明函数、开始、定义变量、循环插入、结束，最后是调用函数。

### 2.1.2 统计查询

进入information_schema 数据库。

```mysql
select table_rows, data_length from tables where table_schema='test';
```

查询新建的表中记录的个数和数据大小。

```mysql
set profiling = 1;
select * from books where name = 'name900000';
show profiles;
set profiling = 0;
```

在不使用索引的情况下，每个查询大概 160ms 左右。

如何统计时间？`set profiling=1` 打开统计信息； `show profiles` 查看执行统计包括时间。profiling 名称，资料收集的作用。

### 2.1.3 优化为索引

```mysql
create index idx_books_name on books(name);
```

100万条数据，建立索引用时 8.68 秒，然后使用索引查询用时 3ms 左右，比不用索引提高了近50倍。

可以使用 `explain` 关键字查看是否语句走了索引。

## 2.2 索引知识

### 2.2.1 索引的最左匹配原则

最左匹配原则：触发多级索引，要按照索引key顺序构建条件筛选过滤。因为建立重复索引是有序的，在左边的要作为第一个匹配来用，如果第一个无法匹配就不走索引了，所以必须要满足最左匹配原则才能走索引。

如index(price, name) 查询不能只找name，那样和不用索引一样，要加上price查询。

那么当建立的索引是重复大选择性低的列时如SEX，如何强制走索引呢？

```mysql
SELECT U.NAME FROM USER WHERE NAME='H' AND SEX IN ('M','F')
```

上面使用了 in 范围操作来强制走索引，因为 sex 只能在 M和F 一个，会包含所有可能，不会再出索引了。

### 2.2.2 索引构建条件

现建立一个索引为 INDEX(PRICE, NAME)，对 WHERE 构建是有条件的：

- where price + name 可以走索引
- where name + price 可以走索引，mysql 优化器会优化为和上面一样
- where price 可以走索引，一级索引可以用
- where name 不能走索引， 二级索引不能用，不满足最左匹配原则

### 2.2.3 优化及防止回表

我们可以对 SELECT 的字段都建立在索引上，形成一个覆盖索引，即要查询的结果都能在索引上找到，这样就不用再回表到聚簇索引查询。

一般在索引上查找到主键值，然后利用这个主键值到聚簇索引二次查找到结果并返回。我们把所有结果都放在索引上，形成覆盖索引，可以防止回表查询。

## 2.3 索引底层

### 2.3.1 索引原理

索引会把字段拿出来新建一个表，这个表只有主键值和该字段。表不带其他字段防止加载内存耗时。索引新建的表会按照字段排序，所以二分查找 logN 时间。查找到字段后，返回字段 主键值，根据这个主键值再找其他字段，这个过程叫回表！

MyISAM，**「B+Tree叶节点的data域存放的是数据记录的地址」**，在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读区相应的数据记录，这被称为“非聚簇索引”

InnoDB，其数据文件本身就是索引文件，相比MyISAM，**「索引文件和数据文件是分离的」**，**「其表数据文件本身就是按B+Tree组织的一个索引结构，树的节点data域保存了完整的数据记录」**，这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引”或者聚集索引，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方，在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。因此，在设计表的时候，不建议使用过长的字段为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

### 2.3.2 存储

机械硬盘读取数据分为两过程：1. 寻址（10ms）2. 读取（0.01ms），可见寻址占用了大量时间。所以InnoDB做了优化，先把关联数据连续存储；再使用预加载预读功能，加载相邻地址的数据到内存。

数据分块存储，每块16KB，数据块又分层存储，按照键的大小构成一个B+树。节点是m长度的数组，子节点是父节点键大小范围内的键。

### 2.3.3 InnoDB 索引

#### 2.3.3.1 聚簇索引

主键构成的B+树，id等；非叶节点只有id属性；叶节点存放id行所有信息。

#### 2.3.3.2 二级索引

索引行构成B+树，可以是price，name等多个；非叶节点和叶节点都存储的索引整行信息；其实一个索引键+必须的id主键，就至少是两个。

#### 2.3.3.3 执行顺序

先在二级索引中找到name1000对应的主键id；然后回表，在聚簇索引中找到此di对应的记录；最后返回所有选择的字段。

id主键的长度越小越好，id短，数据块即节点存储的id越多，这样树的层次越少，查找效率高。保证id值是递增的，不会导致页分裂。where 条件里用不到的字段不创建索引。数据重复且分布平均的表字段不建索引。

## 2.4 索引的优化

### 2.4.1 性能下降解析

性能下降 SQL 执行时间长 ：

-  查询数据过多（拆分字段，条件过滤少）
- Join 过多（先过滤再关联）
- 没有用索引
- 服务器调优

### 2.4.2 优化操作规则

- WHERE 语句要对字段全值匹配
- 最左前缀匹配原则
- 不在索引列做任何操作，如计算，函数，类型转换
- where条件范围多时，无法使用右边范围做索引
- 尽量覆盖索引，减少select *
- 不等于操作无法使用索引，导致全表扫描
- is not null 无法使用索引，is null可以
- like '%xx' 无法使用索引
- 字符串不加单引号，索引失效 
- or 会使索引失效

## 2.5 大表优化

查询时限定数据范围；读写分离，主库负责写，从库负责读；垂直分区，以主键分为多个表；水平分区，分片数据表，1~1w一个表；

### 2.5.1 分表后如何保证ID的全局唯一性

	1. UUID 不能太长且不自增
	2. 数据库自增id，不行需要独立部署数据库防止重复
	3. redis 生成id， 需要用到redis
	4. Twitter的snowflake算法
	5. 美团的Leaf分布式ID生成系统

### 2.5.2 结构优化

**「范式优化」**： 比如消除冗余（节省空间。。）

**「反范式优化」**：比如适当加冗余等（减少join）

**「限定数据的范围」**： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。

**「读/写分离」**： 经典的数据库拆分方案，主库负责写，从库负责读；

**「拆分表」**：分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。

### 2.5.3 对表的拆分

- 垂直拆分：解决表与表之间的 IO 竞争问题。不能解决数据量增长的压力。把不同表放在不同的主机上。
- 水平拆分：解决数据量增长的压力。

方案：**「用户表」** 通过性别拆分为男用户表和女用户表，**「订单表」** 通过已完成和完成中拆分为已完成订单和未完成订单，**「产品表」** 未完成订单放一个server上，已完成订单表和男用户表放一个server上，女用户表放一个server上。

## 2.6 如何设计索引

设计索引要考虑每列的两个因素：频繁度和选择性。

频繁度就是使用的程度，select 经常查询的列就是频繁的。

选择性就是该列的离散程度、字段的重复程度。

频繁使用的列但是选择性差的，比如性别，也是可以作为索引的。

# 3. 事务

事务是一组原子性的SQL查询。即使是一条简单的 select 语句也会被包装成事务去处理。

## 3.1 事务原则 ACID

- Atomaic 原子性（事务内操作要么全部成功，要么全部失败）
- Consistency 一致性（与提交有关，只要没有提交更改都无效，保证前后数据的一致性）
- Isolation 隔离性（一个事务在提交前的修改对其他事务是不可见的）
- Durability 持久性（事务一旦提交，就会永久保存）

## 3.2 数据库读写问题

数据库中多个事务在读写时，会因为隔离级别产生不同的问题，有4个问题。

- 脏读（读到另一个事务未提交的数据）
- 丢失修改（两个事务同时对一个字段写入，一个事务写会丢失无效）
- 不可重复读（一个事务第一次读后，另一个事务修改了，第二次读结果不一样）
- 幻读（另一个事务在其他事务执行的范围行中插入新数据行，会莫名其妙多出数据，形成幻觉）

## 3.3 事务的隔离级别

隔离性很复杂，比较低的隔离性并发性更高，系统开销也低。隔离级别为了解决读写问题保证事务原则。

- 未提交读（事务还没有提交就读了，完全不隔离，导致所有问题，比如脏读）
- 提交读（事务提交后读，导致不可重复读和幻读）
- 可重复读（同一事务多次读取保证数据相同，导致幻读）（InnoDB通过MVCC解决了幻读）
- 可串行化（读取的每一行数据都加锁，可能导致大量超时和锁争用）

# 4. 锁和MVCC

锁和mvcc都属于数据库并发控制，在提高并发性的同时保证数据的ACID原则。MySQL在并发控制上很复杂，每种存储引擎都有自己的一套锁策略和锁粒度。

## 4.1 数据库锁机制

InnoDB 采用两阶段锁定协议，在事务执行过程中随时都可以加锁，只有在commit或rollback时锁才会释放，并且所有锁都在同一时刻释放。这个加锁的过程是隐式锁定，无法控制，InnoDB根据事务隔离级别自动加锁。

InnoDB也提供了显示加锁的方式，通过语句 `lock in share mode` 或 `for update` 加排他锁。但应尽量避免使用，会影响高并发性能。

- 表锁
- 行级锁

### 4.1.2 死锁问题

当两个事务交替对两个记录修改时，会发生死锁。InnoDB 策略是将持有最少行级排他锁的事务进行回滚。

## 4.2 多版本并发控制

MVCC 的实现，是通过保存数据在某个时间点的快照来实现。即对每次修改的事务，都定制一个版本作为快照名，并把当前值保存下来。这个保存并不是简单地在原记录上修改，而是重新生成一行记录，把值更新。

### 4.2.1 简化的MVCC

通过维护一个系统版本号来定义行的创建时间和过期时间，每开始一个事务，系统版本好就会自动递增。

- SELECT （该事务版本号要 》记录的创建版本号 且 《 记录的过期版本号）
- INSERT （插入新行数据记录的同时，把系统版本号也写入）
- DELETE（删除后要保存当前事务版本号作为删除标志）
- UPDATE（插入一行新记录，并保存新版本号）

这样的设计，使得大多数读操作不用加锁。